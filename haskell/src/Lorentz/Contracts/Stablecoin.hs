-- SPDX-FileCopyrightText: 2020 TQ Tezos
-- SPDX-License-Identifier: MIT

module Lorentz.Contracts.Stablecoin
  ( ConfigureMinterParam(..)
  , ChangeMasterMinterParam
  , ChangePauserParam
  , GetCounterParam
  , SetTransferlistParam
  , RemoveMinterParam
  , MetadataRegistryStorage'(..)
  , MetadataRegistryStorage
  , MetadataRegistryStorageView
  , mkMetadataRegistryStorage
  , MintParams
  , MintParam(..)
  , BurnParams
  , ParameterC
  , Parameter (..)
  , Storage(..)
  , StorageView(..)
  , UserPermits(..)
  , PermitInfo(..)
  , Roles(..)

  , TransferOwnershipParam
  , Expiry
  , PermitHash(..)
  , mkPermitHash
  , PermitParam(..)
  , RevokeParam(..)
  , RevokeParams
  , SetExpiryParam
  , GetDefaultExpiryParam
  , minterLimit
  , stablecoinTokenMetadata

  , stablecoinPath
  , metadataRegistryContractPath
  ) where

import Fmt
import qualified Text.Show

import Lorentz
import qualified Lorentz as L
import Morley.Client (BigMapId(..))
import qualified Tezos.Crypto as Hash

import qualified Lorentz.Contracts.Spec.FA2Interface as FA2

-- | The path to the compiled stablecoin contract.
stablecoinPath :: FilePath
stablecoinPath = "./test/resources/stablecoin.tz"

-- | The path to the compiled metadata registry.
metadataRegistryContractPath :: FilePath
metadataRegistryContractPath = "./test/resources/metadata.tz"

------------------------------------------------------------------
-- Parameter

data ConfigureMinterParam = ConfigureMinterParam
 { cmpMinter :: Address
 , cmpCurrentMintingAllowance :: Maybe Natural
 , cmpNewMintingAllowance :: Natural
 }
 deriving stock (Generic, Show)
 deriving anyclass (IsoValue, HasAnnotation)

instance Buildable ConfigureMinterParam where
  build = genericF

type RemoveMinterParam = Address

data MintParam = MintParam
  { mpTo :: Address
  , mpAmount :: Natural
  }
  deriving stock (Show, Generic)
  deriving anyclass (IsoValue, HasAnnotation)

instance Buildable MintParam where
  build = genericF

type MintParams = [MintParam]

type BurnParams = List Natural

type TransferOwnershipParam = Address
type ChangeMasterMinterParam = Address
type ChangePauserParam = Address
type SetTransferlistParam = Maybe Address

newtype PermitHash = PermitHash ByteString
  deriving stock (Generic, Show)
  deriving newtype (IsoValue, L.HasAnnotation, Eq, Ord)

instance Buildable PermitHash where
  build (PermitHash bs) = base64F bs

data PermitParam = PermitParam
  { ppKey :: PublicKey
  , ppSignature :: Signature
  , ppPermitHash :: PermitHash
  }
 deriving stock (Generic, Show)
 deriving anyclass (IsoValue, HasAnnotation)

instance Buildable PermitParam where
  build = genericF

data RevokeParam = RevokeParam
  { rpPermitHash :: PermitHash
  , rpPermitIssuer :: Address
  }
  deriving stock (Show, Generic)

deriving anyclass instance IsoValue RevokeParam
deriving anyclass instance HasAnnotation RevokeParam
instance Buildable RevokeParam where
  build = genericF

type RevokeParams = [RevokeParam]

type Expiry = Natural
type SetExpiryParam = (Expiry, Maybe (PermitHash, Address))

type GetDefaultExpiryParam = View () Expiry

type GetCounterParam = View () Natural

-- | Parameter of Stablecoin contract
data Parameter
  = Accept_ownership
  | Burn BurnParams
  | Call_FA2 FA2.Parameter
  | Change_master_minter ChangeMasterMinterParam
  | Change_pauser ChangePauserParam
  | Configure_minter ConfigureMinterParam
  | Get_counter GetCounterParam
  | Get_default_expiry GetDefaultExpiryParam
  | Mint MintParams
  | Pause
  | Permit PermitParam
  | Remove_minter RemoveMinterParam
  | Revoke RevokeParams
  | Set_expiry SetExpiryParam
  | Set_transferlist SetTransferlistParam
  | Transfer_ownership TransferOwnershipParam
  | Unpause

-- | In order to be able to construct valid permits,
-- the shape of the @or@ tree generated
-- the Michelson representation of 'Parameter' must be an exact match
-- of the Michelson parameter generated by Ligo in @stablecoin.tz@.
--
-- To see the the Michelson representation of 'Parameter':
--
-- >>> import Data.Singletons (demote)
-- >>> import Michelson.Typed (ToT)
-- >>> import Fmt (pretty)
-- >>>
-- >>> pretty $ demote @(ToT Parameter)
$(customGeneric "Parameter" $ withDepths
    [ cstr @5 []       -- %accept_ownership
    , cstr @5 [fld @0] -- %burn
    , cstr @5 [fld @0] -- %call_FA2
    , cstr @5 [fld @0] -- %change_master_minter
    , cstr @5 [fld @0] -- %change_pauser
    , cstr @5 [fld @0] -- %configure_minter
    , cstr @5 [fld @0] -- %get_counter
    , cstr @5 [fld @0] -- %get_default_expiry
    , cstr @5 [fld @0] -- %mint
    , cstr @5 []       -- %pause
    , cstr @5 [fld @0] -- %permit
    , cstr @5 [fld @0] -- %remove_minter
    , cstr @5 [fld @0] -- %revoke
    , cstr @5 [fld @0] -- %set_expiry
    , cstr @5 [fld @0] -- %set_transferlist
    , cstr @5 [fld @0] -- %transfer_ownership
    , cstr @1 []       -- %unpause
    ]
  )

deriving anyclass instance IsoValue Parameter

instance Buildable Parameter where
  build = genericF

instance Show Parameter where
  show = pretty

instance ParameterHasEntrypoints Parameter where
  type ParameterEntrypointsDerivation Parameter = EpdRecursive

type ManagementMichelsonEntrypoints =
    [ "Pause" :> ()
    , "Unpause" :> ()
    , "Configure_minter" :> ConfigureMinterParam
    , "Remove_minter" :> RemoveMinterParam
    , "Mint" :> MintParams
    , "Burn" :> BurnParams
    , "Transfer_ownership" :> TransferOwnershipParam
    , "Accept_ownership" :> ()
    , "Change_master_minter" :> ChangeMasterMinterParam
    , "Change_pauser" :> ChangePauserParam
    , "Set_transferlist" :> SetTransferlistParam
    ]

type PermitEntrypoints =
    [ "Permit" :> PermitParam
    , "Revoke" :> RevokeParams
    , "Set_expiry" :> SetExpiryParam
    , "Get_default_expiry" :> GetDefaultExpiryParam
    ]

type ParameterC param =
  ( FA2.FA2ParameterC param
  , ParameterContainsEntrypoints param ManagementMichelsonEntrypoints
  , ParameterContainsEntrypoints param PermitEntrypoints
  )

-- | Crates a permit that can be issued via the @Permit@ entrypoint, allowing other users
-- to call the contract with the given 'Parameter' value.
mkPermitHash :: Parameter -> PermitHash
mkPermitHash = PermitHash . Hash.blake2b . lPackValue

------------------------------------------------------------------
--- Storage
------------------------------------------------------------------

data UserPermits = UserPermits
  { upExpiry :: Maybe Expiry
  , upPermits :: Map PermitHash PermitInfo
  }
  deriving stock (Show, Generic)
  deriving anyclass (IsoValue, HasAnnotation)

data PermitInfo = PermitInfo
  { piCreatedAt :: Timestamp
  , piExpiry :: Maybe Expiry
  }
  deriving stock (Show, Generic)
  deriving anyclass (IsoValue, HasAnnotation)

data Roles = Roles
  { rMasterMinter :: Address
  , rOwner :: Address
  , rPauser :: Address
  , rPendingOwner :: Maybe Address
  }
  deriving stock (Show)

deriving anyclass instance IsoValue Roles
deriving anyclass instance HasAnnotation Roles
$(customGeneric "Roles" $ withDepths
    [ cstr @0
      [ fld @2
      , fld @2
      , fld @2
      , fld @2
      ]
    ]
  )

data Storage = Storage
  { sDefaultExpiry :: Expiry
  , sLedger :: BigMap Address Natural
  , sMintingAllowances :: Map Address Natural
  , sOperators :: BigMap (Address, Address) ()
  , sIsPaused :: Bool
  , sPermitCounter :: Natural
  , sPermits :: BigMap Address UserPermits
  , sRoles :: Roles
  , sTokenMetadataRegistry :: Address
  , sTransferlistContract :: Maybe Address
  }
  deriving stock (Show)

deriving anyclass instance IsoValue Storage
deriving anyclass instance HasAnnotation Storage
$(customGeneric "Storage" $ withDepths
    [ cstr @0
      [ fld @4 -- sDefaultExpiry
      , fld @4 -- sLedger
      , fld @4 -- sMintingAllowances
      , fld @4 -- sOperators
      , fld @4 -- sIsPaused
      , fld @4 -- sPermitCounter
      , fld @4 -- sPermits
      , fld @4 -- sRoles
      , fld @2 -- sTokenMetadataRegistry
      , fld @2 -- sTransferlistContract
      ]
    ]
  )

-- | Represents a storage value retrieved using the Tezos RPC.
--
-- 'StorageView' is very similar to 'Storage',
-- except 'BigMap's have been replaced by 'BigMapId'.
-- This is because, when a contract's storage is queried, the Tezos RPC returns
-- big_maps' IDs instead of their contents.
data StorageView = StorageView
  { svDefaultExpiry :: Expiry
  , svLedger :: BigMapId Address Natural
  , svMintingAllowances :: Map Address Natural
  , svOperators :: BigMapId (Address, Address) ()
  , svIsPaused :: Bool
  , svPermitCounter :: Natural
  , svPermits :: BigMapId Address UserPermits
  , svRoles :: Roles
  , svTokenMetadataRegistry :: Address
  , svTransferlistContract :: Maybe Address
  }
  deriving stock (Show)

deriving anyclass instance IsoValue StorageView
$(customGeneric "StorageView" $ withDepths
    [ cstr @0
      [ fld @4 -- svDefaultExpiry
      , fld @4 -- svLedger
      , fld @4 -- svMintingAllowances
      , fld @4 -- svOperators
      , fld @4 -- svIsPaused
      , fld @4 -- svPermitCounter
      , fld @4 -- svPermits
      , fld @4 -- svRoles
      , fld @2 -- svTokenMetadataRegistry
      , fld @2 -- svTransferlistContract
      ]
    ]
  )

-- We will hard code stablecoin token metadata here
stablecoinTokenMetadata :: FA2.TokenMetadata
stablecoinTokenMetadata = FA2.TokenMetadata
  { tmTokenId = 0
  , tmSymbol = [mt|TEST|]
  , tmName = [mt|Test|]
  , tmDecimals = 8
  , tmExtras = mempty
  }

-- Currently the contract allows to add upto 12 minters.
minterLimit :: Int
minterLimit = 12

data MetadataRegistryStorage' big_map = MetadataRegistryStorage
  { mrsDummyField :: ()
  , mrsTokenMetadata :: big_map FA2.TokenId FA2.TokenMetadata
  }
  deriving stock Generic

type MetadataRegistryStorage = MetadataRegistryStorage' BigMap
type MetadataRegistryStorageView = MetadataRegistryStorage' BigMapId

deriving stock instance Show (MetadataRegistryStorage)
deriving stock instance Show (MetadataRegistryStorageView)

deriving anyclass instance IsoValue (MetadataRegistryStorage)
deriving anyclass instance IsoValue (MetadataRegistryStorageView)

mkMetadataRegistryStorage :: big_map FA2.TokenId FA2.TokenMetadata -> MetadataRegistryStorage' big_map
mkMetadataRegistryStorage bm = MetadataRegistryStorage () bm
